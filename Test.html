<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      //const a = [1, 2, 3];
      //console.log(1, a);
      //const b = a.slice(0, 2);
      //console.log(2, b);
      //const c = b.concat(4);
      //console.log(3, c);
      //const d = a.slice(2, 3);
      //console.log(d);
      //const e = c.concat(d);
      //console.log(e);

      //배열의 중간 요소 추가
      //const b = a.slice(0, 2).concat(4, a.slice(2, 3));
      //const b = [...a.slice(0, 2), 4, ...a.slice(2, 3)];
      //console.log(b);
      //console.log(...a);

      //스프레드 연산자 ,배열 결합
      //const a = [1, 2, 3];
      //const b = [3, 4, 5];
      //const c = [...a, ...b]; //배열화 시켜서 넣은 거임 //배열 결합
      //console.log(c);
      //console.log(a);
      //console.log(...a);

      //스프레드연산자 = 오브젝트 덮어씀
      //const a = { id: 1, name: "홍길동" };
      //const b = a; //얕은 복사 - 주소 참조만 하는 거
      //const b = { ...a, id: 2, name: "임꺽정" }; //깊은 복사
      //console.log(b);

      //스프레드 연산자 = 오브젝트 결합은 중복이 제거 된다.(중복되면 덮어 쓰니까)
      //const a = { a: 1, b: 2, c: 3, d: 4 };
      //const b = { d: 100, e: 101, f: 102 };
      //const c = { ...a, ...b };
      //console.log(c);

      //검색
      //const names = ["홍길동", "이원모", "홍성수"];
      //const i = names[1].indexOf("홍");
      //console.log(i);

      //const filterNames = names.filter((name) => name.indexOf("홍") !== -1);
      //console.log(filterNames);

      const requestUser = { id: 2, name: "차아령" };
      const users = [
        { id: 1, name: "김성수", phone: "2222" },
        { id: 2, name: "이병근", phone: "3333" },
        { id: 3, name: "김민경", phone: "4444" },
      ];

      const newUsers = users.map((user) =>
        user.id === 2 ? { ...user, ...requestUser } : user
      );
      console.log(newUsers);
    </script>
  </body>
</html>
